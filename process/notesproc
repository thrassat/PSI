
- Definir chaque composant 1 par 1 puis on interconnectera tout ça 

- Demarche : Ces 3 étapes sont valables pour faire chaque composant du process 

		* Voir le composant qu'on veut faire ces interfaces : bus de sortie, bus en entrée 
		* Voir qu'est-ce qu'on doit faire pour donner la bonne valeur au signaux de sortie
		*synchrone si doit garder une information dans le composant (mémoire synchrone) pas besoin on va être asynchrone 


- On crée des VHDL module a chaque fois !
	* on entre ses composants (interface) 
	* 8 ou 16 bits selon l'implementation d'affect a voir 

On part sur l'ALU : ( + / - / * ) 
	- utilisation d'une librairie existante pour les OP ! 
	- dessin pour les bus d'e/s 
	- les flags a faire ! a lever nous même : la carrie dépasse (sur 17 bits et pas 16) 
			Solution : Créer un signal intermédiaire sur 17 bits ppour voir s'il y est ou pas : concatener un 0 sur le A+B en gros ( voir feuille explication) 
					C sera donc le 17e bit de ce signal intermediaire selon ce qu'on a eu ! 
	- etape suivante : Voir comment on leverai les autres flags ! 



TEST : 
	créer un nouveau fichier test bench , et après viré la clock si on est en asynchrone et après on écrit en dessous du wait genre une addition tout ça , on vérifie ensuite 


------ A voir :::::::::::::::::::::::::
	
	ALU : 
		- besoin de cast les signaux avec to_integer avant la multiplication ? 
		- On a fait qq test avec le fichier test bench ça va 

	BR : 
		- A l'air bon 
		- dans le process est-ce que c'est bien elsif et pas un autre if justement ??? 
		- Voir comment faire un testbench qui rend compte des choses!! 

	MEMOIRE DONNEES : 
		- elsif ou if simple pour le process !??? 
		- Comment on modèlise la mémoire de données !


/// TODO 29 MAI 

- IP doit être le compteur du td : ok normalement test 

- Pas besoin de faire que le processeur prend le fichier en entrée, en gros fini 

- Traduction du fichier texte via le mail de remi 



//A sup
-- Initialisation de la mém d'instructions
		IP <= x"06000008" ; 			-- AFC R0 8
		IP <= x"0604000E" ; 			-- AFC R4 14
		IP <= x"060B0004" ; 			-- AFC R11 4				
		IP <= x"01010004" ;			-- ADD R1 R0 R4 (x16 dans r1 : 22 ) 
		IP <= x"020A0B01" ; 			-- MUL R10 R11 R1  ( 22 * 4 = 88 , 58 en hexa dans r10 ) EN signé notre chiffre max est 127
		IP <= x"0302000B";  			-- SUB R2 R0 R11 (8 -4 = 4 a mettre dans r2 ) 
		IP <= x"05030200";         -- COP R3 R2 (r3 prend la valeur de 4) 



	
